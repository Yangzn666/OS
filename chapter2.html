<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第2章 进程管理 - 2025王道操作系统考研复习指导</title>
    <link rel="stylesheet" href="styles.css">
    
    <!-- 进度条 -->
    <div id="progressBar" class="progress-bar"></div>
</head>
<body>
    <header>
        <div class="container">
            <h1>第2章 进程管理</h1>
            <p>2025王道操作系统考研复习指导</p>
        </div>
    </header>

    <nav>
        <div class="container">
            <button class="menu-toggle" onclick="toggleMobileMenu()">☰ 菜单</button>
            <ul>
                <li><a href="index.html">首页</a></li>
                <li><a href="chapter1.html">第1章</a></li>
                <li><a href="chapter2.html">第2章</a></li>
                <li><a href="exercises2.html">第2章习题</a></li>
                <li><a href="chapter3.html">第3章</a></li>
                <li><a href="chapter4.html">第4章</a></li>
                <li><a href="chapter5.html">第5章</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <section id="chapter2" class="chapter">
            <h2>第2章 进程管理</h2>
            
            <!-- 添加章节思维导图 -->
            <div class="mermaid-container">
                <div class="mermaid">
mindmap
  root((第2章<br/>进程管理))
    2.1 进程的基本概念
      程序的顺序执行
      前趋图
      程序的并发执行
      进程的特征与状态
        进程特征
          动态性
          并发性
          独立性
          异步性
        进程状态
          运行态
          就绪态
          阻塞态
          创建态
          结束态
      进程控制块(PCB)
        定义
        包含内容
        作用
    2.2 进程控制
      进程的创建
        创建过程
        创建方式
      进程的终止
        终止方式
        终止过程
      进程的阻塞与唤醒
      进程的挂起与激活
    2.3 进程同步
      基本概念
        同步
        互斥
        临界区
        临界资源
      信号量机制
        整型信号量
        记录型信号量
        PV操作
      信号量的应用
    2.4 经典进程同步问题
      生产者-消费者问题
      哲学家进餐问题
      读者-写者问题
    2.5 管程机制
    2.6 进程通信
      低级通信
      高级通信
        共享内存
        消息传递
        管道
    2.7 线程
      线程概念
      线程实现
      线程控制
    2.8 进程调度
      调度时机
      调度算法
        FCFS
        SJF
        HRN
        RR
        多级队列
        多级反馈队列
      调度性能评价
    2.9 死锁
      死锁概念
      死锁产生的必要条件
      死锁处理方法
        预防
        避免
        检测
        解除
                </div>
            </div>
            
            <div class="content">
                <details>
                    <summary>2.1 进程的基本概念</summary>
                    <div>
                        <h4>2.1.1 程序的顺序执行及其特征</h4>
                        <p><strong>定义：</strong>程序的<strong>顺序执行</strong>是指程序按顺序一条一条地执行</p>
                        <p><strong>实例：</strong>早期的批处理系统中，程序严格按照编写顺序执行，前一条指令执行完毕后才会执行下一条指令。</p>
                        <p><strong><strong>顺序执行</strong>特征：</strong></p>
                        <ol>
                            <li>顺序性：程序执行顺序与编写顺序一致</li>
                            <li>封闭性：程序执行时独占系统资源，结果不受外界影响</li>
                            <li>可再现性：程序执行结果与执行环境无关，可重复</li>
                        </ol>
                        <p><strong>实例：</strong>科学计算程序在相同输入条件下总是产生相同的结果，体现了可再现性。</p>
                        
                        <h4>2.1.2 前趋图</h4>
                        <p><strong>前趋图：</strong>描述程序执行顺序的有向无环图</p>
                        <p><strong>前趋图节点：</strong>表示程序段或指令</p>
                        <p><strong>前趋图有向边：</strong>表示前趋关系，即"先执行"关系</p>
                        <p><strong>前趋图特点：</strong>无环，有向</p>
                        <p><strong>实例：</strong>编译过程可以表示为前趋图：词法分析→语法分析→语义分析→代码生成→代码优化。</p>
                        
                        <h4>2.1.3 程序的并发执行及其特征</h4>
                        <p><strong>定义：</strong>程序的<strong>并发执行</strong>是指多个程序同时运行，宏观上同时发生，微观上交替执行</p>
                        <p><strong>实例：</strong>现代操作系统中，用户可以一边听音乐一边浏览网页，实际上是CPU在多个任务之间快速切换。</p>
                        <p><strong><strong>并发执行</strong>特征：</strong></p>
                        <ol>
                            <li>间断性：执行过程中可能被中断</li>
                            <li>失去封闭性：多个程序共享系统资源，执行结果受其他程序影响</li>
                            <li>不可再现性：执行结果与执行顺序有关，不可重复</li>
                        </ol>
                        <p><strong>实例：</strong>多个进程同时访问同一个文件时，文件的最终内容取决于访问顺序，体现了失去封闭性和不可再现性。</p>
                        
                        <h4>2.1.4 进程的特征与状态</h4>
                        <p><strong><strong>进程</strong>的特征：</strong></p>
                        <ol>
                            <li>动态性：进程是程序的一次执行过程，有生命周期</li>
                            <li>并发性：多个进程在宏观上同时运行</li>
                            <li>独立性：进程是系统中资源分配和调度的基本单位</li>
                            <li>异步性：进程以不可预知的速度向前推进</li>
                        </ol>
                        <p><strong>实例：</strong>浏览器进程、音乐播放器进程、文字处理进程可以同时运行，各自独立，体现了进程的并发性和独立性。</p>
                        
                        <p><strong><strong>进程</strong>的状态：</strong></p>
                        <ol>
                            <li>运行态（Running）：进程占用CPU正在执行</li>
                            <li>就绪态（Ready）：进程已获得除CPU外的所有必要资源，等待分配CPU</li>
                            <li>阻塞态（Blocked）：进程等待某种事件（如I/O完成、信号量）而无法继续执行</li>
                            <li>创建态（New）：进程正在被创建，尚未进入就绪队列</li>
                            <li>结束态（Terminated）：进程执行完成或被终止，等待系统回收资源</li>
                        </ol>
                        <p><strong>实例：</strong>当你打开一个程序时，它首先进入创建态，然后变为就绪态等待CPU，获得CPU后进入运行态，如果需要读取文件则进入阻塞态，文件读取完成后回到就绪态。</p>
                        
                        <div class="study-tip-container">
                            <button class="study-tip-btn" onclick="toggleStudyTip('process-state-tip')">💡 学习提示</button>
                            <div id="process-state-tip" class="study-tip-content" style="display:none;">
                                <h4>记忆方法：</h4>
                                <p><strong>五态模型口诀：</strong>"创就运阻结"，可以联想为"创业就业运势阻挡结局"</p>
                                <p><strong>状态转换理解：</strong></p>
                                <ul>
                                    <li><strong>运行态</strong> - 正在执行，有CPU</li>
                                    <li><strong>就绪态</strong> - 万事俱备，只欠CPU</li>
                                    <li><strong>阻塞态</strong> - 等待某事发生，即使给CPU也无法执行</li>
                                    <li><strong>创建态</strong> - 准备阶段，还在"出生证"办理中</li>
                                    <li><strong>结束态</strong> - "退休"状态，等待"养老金"发放（资源回收）</li>
                                </ul>
                                <p><strong>转换规律：</strong></p>
                                <ul>
                                    <li>运行↔就绪（调度相关）</li>
                                    <li>运行→阻塞（主动等待）</li>
                                    <li>阻塞→就绪（被动唤醒）</li>
                                </ul>
                            </div>
                        </div>
                        
                        <div class="visualization">
                            <h4>进程状态转换图</h4>
                            <pre>
              创建          ┌─────────────┐
        ┌─────────────────┤   新建态    ├─────────调度──────┐
        │                 └─────────────┘                  │
        │                      │                           │
        │                   初始化                        │
        ↓                      ↓                           │
┌─────────────┐         ┌─────────────┐                   │
│   终止态    │◀────────┤   就绪态    │◀──时间片用完───┐   │
└─────────────┘   终止   └─────────────┘               │   │
        ▲                   │    │                     │   │
        │              调度 │    │                     │   │
        │                   ↓    │ I/O请求或其他事件   │   │
        │              ┌─────────────┐               └───┼───┘
        │              │   运行态    │                   │
        │              └─────────────┘                   │
        │                   │    │                     │
        │              时间片用完 │                     │
        │                   │    │ I/O完成或其他事件   │
        │                   ↓    ↓                     │
        │              ┌─────────────┐                 │
        └──────────────┤   阻塞态    │◀────────────────┘
             终止       └─────────────┘
                            </pre>
                            <p>说明：进程可以在不同状态之间转换，箭头表示转换的方向和触发条件</p>
                        </div>
                        
                        <p><strong>状态转换：</strong></p>
                        <ul>
                            <li>就绪→运行：进程被调度程序选中</li>
                            <li>运行→就绪：时间片用完或被更高优先级进程抢占</li>
                            <li>运行→阻塞：等待I/O操作完成或等待信号量</li>
                            <li>阻塞→就绪：等待的事件发生（如I/O完成）</li>
                            <li>创建→就绪：进程创建完毕</li>
                            <li>运行→结束：进程执行完毕</li>
                        </ul>
                        <p><strong>实例：</strong>在多任务操作系统中，当你正在打字时（运行态），系统分配的时间片用完后会切换到其他任务（就绪态），当你按下Ctrl+S保存文档时，系统会等待磁盘写入完成（阻塞态），写入完成后继续等待CPU（就绪态）。</p>
                        
                        <h4>2.1.5 <strong>进程</strong>控制块（PCB）</h4>
                        <p><strong>定义：</strong>操作系统管理<strong>进程</strong>的核心数据结构，是<strong>进程</strong>存在的唯一标志</p>
                        <p><strong>实例：</strong>Linux中的task_struct结构体就是PCB的具体实现。</p>
                        <p><strong>PCB包含的内容：</strong></p>
                        <ol>
                            <li>进程标识符：进程名、进程ID</li>
                            <li>处理机状态：CPU寄存器的值</li>
                            <li>进程调度信息：进程优先级、调度队列指针</li>
                            <li>进程控制信息：程序和数据的地址空间、状态、资源清单</li>
                            <li>其他信息：进程间通信、I/O状态信息</li>
                        </ol>
                        <p><strong>实例：</strong>在Windows任务管理器中可以看到每个进程的PID（进程标识符），这就是PCB中的一部分信息。</p>
                        
                        <p><strong>PCB的作用：</strong></p>
                        <ol>
                            <li>作为进程存在的唯一标识</li>
                            <li>作为操作系统管理进程的依据</li>
                            <li>作为进程调度的依据</li>
                            <li>作为进程同步和通信的依据</li>
                        </ol>
                        <p><strong>实例：</strong>当系统需要切换进程时，会保存当前进程的CPU寄存器状态到PCB中，然后从下一个进程的PCB中恢复其状态。</p>
                    </div>
                </details>
                
                <details>
                    <summary>2.2 进程控制</summary>
                    <div>
                        <h4>2.2.1 <strong>进程</strong>的创建</h4>
                        <p><strong>创建过程：</strong></p>
                        <ol>
                            <li>申请空闲PCB</li>
                            <li>为进程分配资源</li>
                            <li>初始化PCB</li>
                            <li>将新进程插入就绪队列</li>
                        </ol>
                        <p><strong>实例：</strong>在Linux中执行fork()系统调用创建子进程时，系统会执行上述步骤。</p>
                        
                        <p><strong>创建方式：</strong></p>
                        <ol>
                            <li>系统初始化时创建</li>
                            <li>用户请求创建</li>
                            <li>进程创建新进程</li>
                        </ol>
                        <p><strong>实例：</strong>系统启动时创建init进程（系统初始化）；用户双击图标启动程序（用户请求）；Web服务器为每个客户端请求创建处理进程（进程创建新进程）。</p>
                        
                        <p><strong>进程创建时的调度：</strong>创建新进程会触发调度程序，因为就绪队列发生变化</p>
                        <p><strong>实例：</strong>当系统创建一个新的高优先级进程时，调度器可能会立即切换到该进程执行。</p>
                        
                        <h4>2.2.2 <strong>进程</strong>的终止</h4>
                        <p><strong>终止方式：</strong></p>
                        <ol>
                            <li>正常退出（执行完毕）</li>
                            <li>异常退出（运行时错误）</li>
                            <li>被其他进程杀死</li>
                        </ol>
                        <p><strong>实例：</strong>程序执行完main函数正常退出；程序因除零错误而崩溃异常退出；用户通过任务管理器强制结束进程。</p>
                        
                        <p><strong>终止过程：</strong></p>
                        <ol>
                            <li>从PCB中移除进程</li>
                            <li>释放进程占用的资源</li>
                            <li>通知父进程</li>
                        </ol>
                        <p><strong>实例：</strong>在Linux中，当子进程终止时会向父进程发送SIGCHLD信号通知其终止。</p>
                        
                        <p><strong>进程退出时的调度：</strong>进程退出时处理机会空闲，需要调度程序选择新进程</p>
                        <p><strong>实例：</strong>当一个进程执行完毕退出后，CPU空闲，调度器会选择就绪队列中的下一个进程执行。</p>
                        
                        <h4>2.2.3 <strong>进程</strong>的阻塞与唤醒</h4>
                        <p><strong>阻塞：</strong>运行中的<strong>进程</strong>等待某事件发生（如I/O完成、等待信号量）</p>
                        <ul>
                            <li>进程从运行态变为阻塞态</li>
                            <li>操作系统将进程从运行队列移出，插入阻塞队列</li>
                            <li>释放CPU，等待事件发生</li>
                        </ul>
                        <p><strong>实例：</strong>当程序需要从磁盘读取文件时，会进入阻塞状态，等待磁盘I/O操作完成。</p>
                        
                        <p><strong>唤醒：</strong>等待的事件发生（如I/O完成、信号量可用）</p>
                        <ul>
                            <li>操作系统将进程从阻塞队列移出，插入就绪队列</li>
                            <li>进程从阻塞态变为就绪态</li>
                            <li>事件发生时可能触发调度程序</li>
                        </ul>
                        <p><strong>实例：</strong>磁盘读取完成后，操作系统会将等待该I/O操作的进程从阻塞队列移到就绪队列。</p>
                        
                        <h4>2.2.4 <strong>进程</strong>的挂起与激活</h4>
                        <p><strong>挂起：</strong>将<strong>进程</strong>从内存移到外存</p>
                        <p><strong>挂起状态：</strong>处于就绪挂起、阻塞挂起</p>
                        <p><strong>挂起原因：</strong>内存不足、进程等待事件发生但不需要CPU</p>
                        <p><strong>实例：</strong>当系统内存紧张时，操作系统可能会将长时间未运行的进程挂起到磁盘上。</p>
                        
                        <p><strong>挂起状态：</strong></p>
                        <ol>
                            <li>就绪挂起：进程已具备运行条件，但被移到外存</li>
                            <li>阻塞挂起：进程等待事件，但被移到外存</li>
                        </ol>
                        <p><strong>实例：</strong>后台的媒体播放器进程可能被挂起以节省内存，当用户切换到该应用时再激活。</p>
                        
                        <p><strong>挂起过程：</strong></p>
                        <ol>
                            <li>将进程从内存移出到外存</li>
                            <li>更新PCB状态</li>
                            <li>释放进程占用的内存</li>
                        </ol>
                        <p><strong>实例：</strong>Windows的虚拟内存管理机制会将不常用的进程页面交换到磁盘的页面文件中。</p>
                        
                        <p><strong>激活：</strong>将<strong>进程</strong>从外存移入内存</p>
                        <p>激活后进程可能进入就绪态或阻塞态</p>
                        <p>例如：处于阻塞挂起状态的进程等待的事件出现时，将此进程转为就绪挂起状态，重新被调入内存后变为就绪态</p>
                        <p><strong>实例：</strong>当你切换回一个被挂起的应用程序时，系统会将其从磁盘重新加载到内存中。</p>
                    </div>
                </details>
                
                <details>
                    <summary>2.3 进程同步</summary>
                    <div>
                        <h4>2.3.1 <strong>进程</strong>同步的基本概念</h4>
                        <p><strong>同步：</strong>多个相关<strong>进程</strong>在执行次序上的相互制约关系</p>
                        <p><strong>实例：</strong>生产者-消费者模型中，消费者必须等待生产者生产出产品后才能消费。</p>
                        <p><strong>进程同步互斥：</strong>多个进程不能同时进入访问同一资源的临界区</p>
                        <p><strong>实例：</strong>多个进程不能同时写入同一个文件，需要互斥访问。</p>
                        <p><strong>进程同步临界区：</strong>进程中访问临界资源的那段代码</p>
                        <p><strong>实例：</strong>对共享变量进行读-修改-写的代码段就是临界区。</p>
                        <p><strong>进程同步临界资源：</strong>一次只允许一个进程使用的资源</p>
                        <p><strong>实例：</strong>打印机、磁带机等硬件设备是典型的临界资源。</p>
                        
                        <p><strong>进程同步机制要求：</strong></p>
                        <ol>
                            <li>空闲让进：临界区空闲时，允许进程进入</li>
                            <li>忙则等待：临界区忙时，进程等待</li>
                            <li>有限等待：进程等待时间有限</li>
                            <li>让权等待：等待的进程释放CPU，避免忙等待</li>
                        </ol>
                        <p><strong>实例：</strong>排队使用ATM机体现了同步机制：ATM空闲时允许用户使用（空闲让进），有人使用时其他人需要排队等待（忙则等待）。</p>
                        
                        <h4>2.3.2 信号量机制</h4>
                        <p><strong>信号量：</strong>一种整型变量，用于表示资源数量</p>
                        <p><strong>实例：</strong>停车场的空余车位数可以用信号量表示，每辆车进入车位数减1，离开车位数加1。</p>
                        <p><strong>整型信号量：</strong>简单的整型变量，不满足让权等待</p>
                        <p><strong>记录型信号量：</strong>包含整型变量和等待队列</p>
                        <p><strong>实例：</strong>POSIX信号量、System V信号量是记录型信号量的具体实现。</p>
                        
                        <p><strong>PV操作：</strong></p>
                        <p>P操作（wait）：申请资源，若资源可用则使用，否则等待</p>
                        <pre><code>P(S) {
while (S <= 0);
S--;
}</code></pre>
                        
                        <div class="study-tip-container">
                            <button class="study-tip-btn" onclick="toggleStudyTip('p-operation-tip')">💡 学习提示</button>
                            <div id="p-operation-tip" class="study-tip-content" style="display:none;">
                                <h4>记忆方法：</h4>
                                <p><strong>P操作（Proberen/Passeren，荷兰语"尝试"或"通过"）</strong></p>
                                <ul>
                                    <li>形象理解：过独木桥前先试探一下是否可以通过</li>
                                    <li>联想记忆："Pass"（通过）的首字母，通过前先检查</li>
                                    <li>中文联想："拍"操作，拍一拍资源看看有没有</li>
                                </ul>
                            </div>
                        </div>
                        
                        <p>V操作（signal）：释放资源，唤醒等待进程</p>
                        <pre><code>V(S) {
S++;
if (S <= 0) {
唤醒等待队列中的一个进程
}
}</code></pre>
                        
                        <div class="study-tip-container">
                            <button class="study-tip-btn" onclick="toggleStudyTip('v-operation-tip')">💡 学习提示</button>
                            <div id="v-operation-tip" class="study-tip-content" style="display:none;">
                                <h4>记忆方法：</h4>
                                <p><strong>V操作（Verhogen/Vrijmaken，荷兰语"增加"或"释放"）</strong></p>
                                <ul>
                                    <li>形象理解：过完桥后给后面的人腾出空间</li>
                                    <li>联想记忆："Value"（价值）的首字母，释放资源增加价值</li>
                                    <li>中文联想："V"字形胜利手势，释放资源获得胜利</li>
                                </ul>
                            </div>
                        </div>
                        
                        <p><strong>实例：</strong>使用信号量控制对共享打印机的访问：P(printer_semaphore)获取打印机，使用完毕后V(printer_semaphore)释放打印机。</p>
                        
                        <p><strong>信号量的分类：</strong></p>
                        <ol>
                            <li>互斥信号量：初始值为1，用于实现互斥</li>
                            <li>同步信号量：初始值大于1，用于实现进程同步</li>
                        </ol>
                        <p><strong>实例：</strong>互斥信号量用于保护临界区；同步信号量用于协调生产者和消费者进程。</p>
                        
                        <h4>2.3.3 信号量的应用</h4>
                        <p>生产者-消费者问题：使用信号量解决生产者和消费者对缓冲区的访问</p>
                        <p>读者-写者问题：使用信号量解决读者和写者对共享数据的访问</p>
                        <p>哲学家进餐问题：使用信号量解决哲学家进餐的同步问题</p>
                        <p><strong>实例：</strong>数据库管理系统使用读者-写者问题的解决方案来处理并发查询和更新操作。</p>
                    </div>
                </details>
                
                <details>
                    <summary>2.4 经典进程的同步问题</summary>
                    <div>
                        <h4>2.4.1 生产者-消费者问题</h4>
                        <p><strong>问题描述：</strong>生产者不断生产产品，消费者不断消费产品，共享一个缓冲区</p>
                        <p><strong>实例：</strong>音频播放器中，解码线程（生产者）不断解码音频数据放入缓冲区，播放线程（消费者）从缓冲区取出数据播放。</p>
                        
                        <p><strong>同步条件：</strong></p>
                        <ol>
                            <li>生产者和消费者不能同时访问缓冲区</li>
                            <li>生产者不能在缓冲区满时生产</li>
                            <li>消费者不能在缓冲区空时消费</li>
                        </ol>
                        <p><strong>实例：</strong>餐厅厨房（生产者）和顾客（消费者）之间的协调：厨师不能在菜品摆满柜台时继续摆放，服务员不能在柜台无菜时取菜。</p>
                        
                        <p><strong>解决方案：</strong></p>
                        <p>互斥信号量：mutex（用于保护缓冲区）</p>
                        <p>同步信号量：full（表示缓冲区中已满的产品数）、empty（表示缓冲区中空闲位置数）</p>
                        <p><strong>实例：</strong>在实际编程中，可以使用pthread库中的互斥锁和条件变量来实现类似功能。</p>
                        
                        <p><strong>伪代码：</strong></p>
                        <pre><code>// 生产者
while (true) {
生产一个产品;
P(empty);
P(mutex);
将产品放入缓冲区;
V(mutex);
V(full);
}

// 消费者
while (true) {
P(full);
P(mutex);
从缓冲区取出产品;
V(mutex);
V(empty);
消费产品;
}</code></pre>
                        <p><strong>实例：</strong>Java中的BlockingQueue类就是生产者-消费者问题的一个高效实现。</p>
                        
                        <h4>2.4.2 哲学家进餐问题</h4>
                        <p><strong>问题描述：</strong>5个哲学家围坐在圆桌旁，每人左右各有一根筷子，哲学家需要两根筷子才能进餐</p>
                        <p><strong>实例：</strong>多线程程序中多个线程需要同时获取两个不同的锁资源的情况。</p>
                        
                        <p><strong>同步条件：</strong></p>
                        <ol>
                            <li>任何两个哲学家不能同时进餐</li>
                            <li>每个哲学家必须能够进餐</li>
                        </ol>
                        <p><strong>实例：</strong>项目团队成员需要同时使用会议室和投影仪开会，但资源有限需要协调。</p>
                        
                        <p><strong>解决方案：</strong></p>
                        <p>互斥信号量：chopstick[5]（每根筷子一个信号量）</p>
                        <p><strong>实例：</strong>为了避免死锁，可以让奇数号哲学家先拿左边筷子再拿右边筷子，偶数号哲学家相反。</p>
                        
                        <p><strong>伪代码：</strong></p>
                        <pre><code>// 哲学家i
while (true) {
think();
P(chopstick[i]);
P(chopstick[(i+1)%5]);
eat();
V(chopstick[i]);
V(chopstick[(i+1)%5]);
}</code></pre>
                        <p><strong>实例：</strong>银行家算法可以用来避免这类资源竞争问题。</p>
                        
                        <p><strong>死锁问题：</strong>所有哲学家同时拿起左筷子，无法再拿起右筷子，导致死锁</p>
                        <p><strong>实例：</strong>交通拥堵时，每个路口的车辆都不愿后退，导致整个交通系统瘫痪。</p>
                        
                        <h4>2.4.3 读者-写者问题</h4>
                        <p><strong>问题描述：</strong>多个读者可以同时读共享数据，但写者必须独占访问</p>
                        <p><strong>实例：</strong>图书馆中多人可以同时查阅图书（读操作），但借还书（写操作）需要独占处理。</p>
                        
                        <p><strong>同步条件：</strong></p>
                        <ol>
                            <li>读者可以同时读</li>
                            <li>读者和写者不能同时访问</li>
                            <li>写者和写者不能同时访问</li>
                        </ol>
                        <p><strong>实例：</strong>数据库系统允许多个用户同时查询数据，但更新操作需要独占访问。</p>
                        
                        <p><strong>解决方案：</strong></p>
                        <p>互斥信号量：rw_mutex（用于保护写操作）</p>
                        <p>计数器：read_count（记录当前读进程数量）</p>
                        <p>互斥信号量：read_mutex（用于保护read_count）</p>
                        <p><strong>实例：</strong>MySQL数据库使用读写锁来解决这类并发访问问题。</p>
                        
                        <p><strong>伪代码：</strong></p>
                        <pre><code>// 读者
while (true) {
P(read_mutex);
read_count++;
if (read_count == 1) {
P(rw_mutex); // 第一个读者获取写锁
}
V(read_mutex);
read();
P(read_mutex);
read_count--;
if (read_count == 0) {
V(rw_mutex); // 最后一个读者释放写锁
}
V(read_mutex);
}

// 写者
while (true) {
P(rw_mutex);
write();
V(rw_mutex);
}</code></pre>
                        <p><strong>实例：</strong>Redis使用类似的机制来处理并发读写操作。</p>
                    </div>
                </details>
                
                <details>
                    <summary>2.5 管程机制</summary>
                    <div>
                        <h4>2.5.1 管程的基本概念</h4>
                        <p><strong>管程定义：</strong>管程是将共享数据和对共享数据的操作封装在一起的机制</p>
                        <p><strong>实例：</strong>面向对象编程中的类就是管程思想的体现，私有成员变量相当于共享数据，公有方法相当于对共享数据的操作。</p>
                        
                        <p><strong>管程组成：</strong></p>
                        <ol>
                            <li>共享数据：被多个进程访问的数据</li>
                            <li>对共享数据的操作：操作共享数据的函数</li>
                            <li>互斥机制：确保同一时刻只有一个进程可以执行操作</li>
                        </ol>
                        <p><strong>实例：</strong>Java中的synchronized关键字和内置锁机制实现了管程的概念。</p>
                        
                        <p><strong>管程特点：</strong></p>
                        <ol>
                            <li>管程中的数据只能被管程内的操作访问</li>
                            <li>管程中的操作是原子的</li>
                            <li>管程的互斥由编译器保证</li>
                        </ol>
                        <p><strong>实例：</strong>C#中的lock语句和Monitor类提供了管程机制。</p>
                        
                        <h4>2.5.2 利用管程解决生产者-消费者问题</h4>
                        <p><strong>管程定义：</strong></p>
                        <pre><code>monitor Buffer {
int count = 0;
int buffer[10];
condition full, empty;

void insert(int item) {
if (count == 10) {
full.wait();
}
buffer[count] = item;
count++;
empty.signal();
}

int remove() {
if (count == 0) {
empty.wait();
}
count--;
full.signal();
return buffer[count];
}
}</code></pre>
                        <p><strong>实例：</strong>Java中的BlockingQueue接口及其实现类（如ArrayBlockingQueue）就是基于管程机制。</p>
                        
                        <p><strong>生产者和消费者调用：</strong></p>
                        <pre><code>// 生产者
while (true) {
item = produce();
Buffer.insert(item);
}

// 消费者
while (true) {
item = Buffer.remove();
consume(item);
}</code></pre>
                        <p><strong>实例：</strong>Go语言中的channel机制在某种程度上也体现了管程的思想。</p>
                    </div>
                </details>
                
                <details>
                    <summary>2.6 进程通信</summary>
                    <div>
                        <h4>2.6.1 进程通信的类型</h4>
                        <p><strong>低级通信：</strong>传递少量信息，如信号量</p>
                        <p><strong>实例：</strong>Unix/Linux中的信号（signal）机制是一种低级通信方式。</p>
                        <p><strong>高级通信：</strong>传递大量信息，如消息传递</p>
                        <p><strong>实例：</strong>网络通信、文件传输等传递大量数据的通信方式。</p>
                        
                        <p><strong>通信方式：</strong></p>
                        <ol>
                            <li>共享内存：多个进程共享同一块内存区域</li>
                            <li>消息传递：进程通过发送和接收消息进行通信</li>
                            <li>管道：一种特殊的通信方式，用于进程间通信</li>
                        </ol>
                        <p><strong>实例：</strong>共享内存类似于多个办公室共享一个公告板；消息传递像发送电子邮件；管道像邮政信箱。</p>
                        
                        <h4>2.6.2 消息传递通信的实现方法</h4>
                        <p><strong>直接通信：</strong>发送进程直接指定接收进程</p>
                        <ul>
                            <li>通信双方必须事先知道对方</li>
                            <li>优点：简单</li>
                            <li>缺点：缺乏灵活性</li>
                        </ul>
                        <p><strong>实例：</strong>电子邮件需要知道接收方的邮箱地址。</p>
                        
                        <p><strong>间接通信：</strong>通过中间对象（如邮箱）进行通信</p>
                        <ul>
                            <li>通信双方不需要知道对方</li>
                            <li>优点：灵活性高</li>
                            <li>缺点：实现复杂</li>
                        </ul>
                        <p><strong>实例：</strong>论坛发帖不需要知道谁会阅读帖子；微博发布内容不需要知道谁会看到。</p>
                        
                        <h4>2.6.3 消息传递系统实现中的若干问题</h4>
                        <p><strong>消息缓冲区的管理：</strong></p>
                        <ol>
                            <li>消息缓冲区的大小</li>
                            <li>消息缓冲区的分配和回收</li>
                        </ol>
                        <p><strong>实例：</strong>网络数据包缓冲区需要合理管理，防止溢出或浪费。</p>
                        
                        <p><strong>同步问题：</strong></p>
                        <ol>
                            <li>发送进程的同步：发送进程在消息发送后是否等待</li>
                            <li>接收进程的同步：接收进程在消息到达前是否等待</li>
                        </ol>
                        <p><strong>实例：</strong>同步发送需要等待接收方确认，异步发送不需要等待。</p>
                        
                        <p><strong>死锁问题：</strong></p>
                        <ol>
                            <li>发送进程等待接收进程</li>
                            <li>接收进程等待发送进程</li>
                        </ol>
                        <p><strong>实例：</strong>两个人打电话时都等着对方先说话，就会形成死锁。</p>
                        
                        <h4>2.6.4 消息缓冲队列通信机制</h4>
                        <p><strong>消息缓冲队列：</strong>用于存放消息的队列</p>
                        <p><strong>实例：</strong>RabbitMQ、Apache Kafka等消息队列系统。</p>
                        
                        <p><strong>工作流程：</strong></p>
                        <ol>
                            <li>发送进程将消息放入消息缓冲队列</li>
                            <li>接收进程从消息缓冲队列中取出消息</li>
                            <li>消息缓冲队列可以是单向或双向</li>
                        </ol>
                        <p><strong>实例：</strong>快递站的工作流程：寄件人将包裹放入快递站（队列），收件人从快递站取出包裹。</p>
                        
                        <p><strong>实现方式：</strong></p>
                        <ul>
                            <li>单向队列：消息从发送进程流向接收进程</li>
                            <li>双向队列：消息可以双向流动</li>
                        </ul>
                        <p><strong>实例：</strong>单向队列像邮件发送；双向队列像电话通话。</p>
                    </div>
                </details>
                
                <details>
                    <summary>2.7 线程</summary>
                    <div>
                        <h4>2.7.1 线程的基本概念</h4>
                        <p><strong>定义：</strong>线程是进程中的一个执行流，是CPU调度的基本单位</p>
                        <p><strong>实例：</strong>浏览器进程中的多个线程：UI线程、网络请求线程、JavaScript执行线程等。</p>
                        
                        <p><strong>线程与进程的区别：</strong></p>
                        <ol>
                            <li>资源分配：进程是资源分配的基本单位，线程是CPU调度的基本单位</li>
                            <li>独立性：进程之间相互独立，线程之间共享进程的资源</li>
                            <li>创建和销毁：线程创建和销毁比进程快</li>
                            <li>通信：线程间通信比进程间通信快</li>
                        </ol>
                        <p><strong>实例：</strong>启动多个进程像开多家公司，启动多个线程像在同一家公司设立多个工作组。</p>
                        
                        <h4>2.7.2 线程间的同步和通信</h4>
                        <p><strong>同步：</strong>线程间同步可以通过互斥锁、信号量等机制</p>
                        <p><strong>实例：</strong>Java中的synchronized关键字、ReentrantLock类。</p>
                        <p><strong>通信：</strong>线程间通信可以通过共享内存、消息传递等机制</p>
                        <p><strong>实例：</strong>Java中的wait()/notify()机制、Go语言中的channel。</p>
                        
                        <h4>2.7.3 内核支持线程和用户级线程</h4>
                        <p><strong>内核支持线程：</strong></p>
                        <ul>
                            <li>由操作系统内核管理</li>
                            <li>内核可以调度线程</li>
                            <li>优点：可以利用多核CPU</li>
                            <li>缺点：线程切换开销大</li>
                        </ul>
                        <p><strong>实例：</strong>Windows线程、Linux pthread都是内核支持线程。</p>
                        
                        <p><strong>用户级线程：</strong></p>
                        <ul>
                            <li>由用户空间的线程库管理</li>
                            <li>内核不知道线程的存在</li>
                            <li>优点：线程切换开销小</li>
                            <li>缺点：不能利用多核CPU</li>
                        </ul>
                        <p><strong>实例：</strong>GNU Pth线程库、早期Java线程实现。</p>
                        
                        <h4>2.7.4 线程控制</h4>
                        <p>线程创建：创建线程并设置初始状态</p>
                        <p>线程终止：终止线程并回收资源</p>
                        <p>线程阻塞：线程等待事件发生</p>
                        <p>线程唤醒：唤醒等待的线程</p>
                        <p>线程同步：使用互斥锁、信号量等机制</p>
                        <p><strong>实例：</strong>C++11中的std::thread类提供了线程控制的各种方法。</p>
                    </div>
                </details>
                
                <details>
                    <summary>2.8 进程调度</summary>
                    <div>
                        <h4>2.8.1 调度的时机</h4>
                        <p><strong>进程调度时机：</strong></p>
                        <ol>
                            <li>进程终止</li>
                            <li>进程阻塞</li>
                            <li>时间片用完</li>
                            <li>有更高优先级的进程进入就绪队列</li>
                            <li>系统调用返回</li>
                        </ol>
                        <p><strong>实例：</strong>当你在视频会议中切换到其他应用时，视频会议进程会因失去焦点而触发调度。</p>
                        
                        <p><strong>关键点：</strong></p>
                        <ul>
                            <li>当一个进程处于内核程序临界区并且这个临界区是要访问就绪队列的话，那么在访问之前它会把这个就绪队列上锁</li>
                            <li>如果进程此时处于普通程序临界区并且这个临界区是要访问普通的临界资源比如打印机的话，那也会在访问之前上锁</li>
                        </ul>
                        <p><strong>实例：</strong>银行取款机系统在更新账户余额时会对账户记录加锁，防止并发修改。</p>
                        
                        <h4>2.8.2 调度的切换与过程</h4>
                        <p><strong>进程调度切换过程：</strong></p>
                        <ol>
                            <li>保存当前进程的CPU状态</li>
                            <li>更新当前进程的PCB（状态、时间片等）</li>
                            <li>从就绪队列中选择一个进程</li>
                            <li>更新新进程的PCB</li>
                            <li>恢复新进程的CPU状态</li>
                        </ol>
                        <p><strong>实例：</strong>就像舞台剧换演员：先记录下台演员的表演状态，然后安排新演员上台并告诉他们剧情进展。</p>
                        
                        <p><strong>进程调度切换方式：</strong></p>
                        <ul>
                            <li>抢占式调度：允许高优先级进程抢占CPU</li>
                            <li>非抢占式调度：进程一旦占用CPU，直到运行结束或阻塞</li>
                        </ul>
                        <p><strong>实例：</strong>实时系统（如飞行控制系统）使用抢占式调度；批处理系统常用非抢占式调度。</p>
                        
                        <h4>2.8.3 <strong>进程调度算法</strong></h4>
                        <p>先来先服务（FCFS）：按照进程进入就绪队列的顺序调度</p>
                        <p>短作业优先（SJF）：优先调度估计运行时间短的进程</p>
                        <p>优先级调度：优先调度优先级高的进程</p>
                        <p>轮转调度（RR）：每个进程轮流执行一个时间片</p>
                        <p>多级反馈队列调度：将进程放在多个优先级队列中，根据运行情况动态调整优先级</p>
                        <p><strong>实例：</strong>火车站售票窗口采用FCFS原则；医院急诊科采用优先级调度；CPU调度通常使用时间片轮转。</p>
                    </div>
                </details>
                
                <details>
                    <summary>2.9 本章总结与核心考点</summary>
                    <div>
                        <p><strong><strong>进程</strong>核心概念：</strong><strong>进程</strong>是程序的一次执行，是系统进行资源分配和调度的基本单位</p>
                        <p><strong>实例：</strong>就像剧本（程序）和演出（进程）的关系，一个剧本可以有多场演出。</p>
                        
                        <p><strong><strong>进程</strong>状态转换：</strong>运行、就绪、阻塞、创建、结束</p>
                        <p><strong>实例：</strong>学生上课状态：正在讲课（运行）、课间休息（就绪）、请假（阻塞）、刚入学（创建）、毕业（结束）。</p>
                        
                        <p><strong><strong>进程</strong>控制块PCB：</strong><strong>进程</strong>存在的唯一标志，包含<strong>进程</strong>的标识符、状态、优先级、资源分配情况等</p>
                        <p><strong>实例：</strong>身份证是人的唯一标识，PCB是进程的唯一标识。</p>
                        
                        <p><strong><strong>进程</strong>控制：</strong>创建、终止、阻塞、唤醒、挂起、激活</p>
                        <p><strong>实例：</strong>员工入职、离职、请假、复工、出差、返岗的管理流程。</p>
                        
                        <p><strong><strong>进程</strong>同步：</strong>临界区、互斥、<strong>信号量</strong>机制、<strong>管程</strong></p>
                        <p><strong>实例：</strong>交通信号灯控制系统协调车辆通行。</p>
                        
                        <p><strong>经典<strong>进程同步</strong>问题：</strong>生产者-消费者、哲学家进餐、读者-写者</p>
                        <p><strong>实例：</strong>餐厅运营中的各种协调问题。</p>
                        
                        <p><strong><strong>进程</strong>通信：</strong>共享内存、消息传递、管道</p>
                        <p><strong>实例：</strong>人与人之间的交流方式：面对面交谈（共享内存）、写信（消息传递）、传话筒（管道）。</p>
                        
                        <p><strong><strong>线程</strong>：</strong><strong>线程</strong>与<strong>进程</strong>的区别、内核支持<strong>线程</strong>与用户级<strong>线程</strong></p>
                        <p><strong>实例：</strong>公司（进程）和部门（线程）的关系。</p>
                        
                        <p><strong><strong>进程</strong>调度机制：</strong>调度时机、切换过程、<strong>调度算法</strong></p>
                        <p><strong>实例：</strong>机场跑道调度飞机起降。</p>
                        
                        <p><strong>本章重要性：</strong>本章是操作系统的核心内容，也是考研的重点和难点，需要深入理解进程的基本概念、状态转换、同步机制和调度算法，为后续章节的学习奠定基础。</p>
                    </div>
                </details>
            </div>
            
            <div class="key-points">
                <h3>核心考点</h3>
                <ul>
                    <li><strong>进程同步机制</strong>（<strong>信号量</strong>）</li>
                    <li><strong>死锁</strong>（<strong>银行家算法</strong>）</li>
                    <li><strong>调度算法</strong></li>
                </ul>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 王道操作系统考研复习指导 - 学习网站</p>
        </div>
    </footer>

    <script src="script.js"></script>
    
    <!-- Mermaid.js 支持 -->
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            mindmap: {
                useMaxWidth: true,
                padding: 20,
                nodeSpacing: 60,
                rankSpacing: 100
            },
            themeVariables: {
                primaryColor: '#667eea',
                primaryBorderColor: '#764ba2',
                primaryTextColor: '#ffffff',
                secondaryColor: '#a8dcfa',
                secondaryBorderColor: '#8bc4f9',
                secondaryTextColor: '#333333',
                tertiaryColor: '#f5f7fa',
                tertiaryBorderColor: '#e4edf9',
                tertiaryTextColor: '#333333',
                lineColor: '#667eea',
                fontSize: 20
            }
        });
    </script>
    
    <!-- 回到顶部按钮 -->
    <button id="backToTop" class="back-to-top">↑</button>
</body>
</html>