<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第3章 内存管理 - 2025王道操作系统考研复习指导</title>
    <link rel="stylesheet" href="styles.css">
    
    <!-- 进度条 -->
    <div id="progressBar" class="progress-bar"></div>
</head>
<body>
    <header>
        <div class="container">
            <h1>第3章 内存管理</h1>
            <p>2025王道操作系统考研复习指导</p>
        </div>
    </header>

    <nav>
        <div class="container">
            <button class="menu-toggle" onclick="toggleMobileMenu()">☰ 菜单</button>
            <ul>
                <li><a href="index.html">首页</a></li>
                <li><a href="chapter1.html">第1章</a></li>
                <li><a href="chapter2.html">第2章</a></li>
                <li><a href="chapter3.html">第3章</a></li>
                <li><a href="exercises3.html">第3章习题</a></li>
                <li><a href="chapter4.html">第4章</a></li>
                <li><a href="chapter5.html">第5章</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <section id="chapter3" class="chapter">
            <h2>第3章 内存管理</h2>
            
            <!-- 添加章节思维导图 -->
            <div class="mermaid-container">
                <div class="mermaid">
mindmap
  root((第3章<br/>内存管理))
    3.1 内存管理基础
      内存的基本概念
      地址类型
        物理地址
        逻辑地址
      从写程序到程序运行
      链接的三种方式
        静态链接
        装入时动态链接
        运行时动态链接
      装入的三种方式
        绝对装入
        可重定位装入
        动态重定位
      内存管理的四大功能
        内存分配
        内存保护
        地址映射
        内存扩充
    3.2 连续分配管理方式
      单一连续分配
      固定分区分配
      动态分区分配
      动态分区分配算法
        首次适应算法
        最佳适应算法
        最坏适应算法
        邻近适应算法
    3.3 非连续分配管理方式
      分页存储管理方式
        基本分页
        地址变换机构
          基本地址变换
          快表地址变换
          两级页表
        页表结构
      分段存储管理方式
        基本思想
        地址转换
      段页式管理方式
        基本思想
        地址转换
    3.4 虚拟内存管理
      虚拟内存基本概念
      请求分页管理方式
      页面置换算法
        最佳置换算法
        先进先出算法
        最近最少使用算法
        时钟置换算法
      抖动现象
      工作集
    3.5 页面分配策略
      分配策略
      调入策略
      置换策略
                </div>
            </div>
            
            <div class="content">
                <details>
                    <summary>3.1 内存管理基础</summary>
                    <div>
                        <h4>3.1.1 内存的基本概念</h4>
                        <p><strong><strong>内存</strong>的定义：</strong><strong>内存</strong>是用于存放数据的硬件，程序执行前需要先放到<strong>内存</strong>中才能被<span class="highlight">CPU</span>处理</p>
                        <p><strong>实例：</strong>就像做饭需要把食材放在灶台上一样，程序运行需要把代码和数据放在内存中。</p>
                        <p><strong>存储单元：</strong>内存中每个单位就是存储单元</p>
                        <p><strong>实例：</strong>可以把内存想象成一个有很多格子的药盒，每个格子就是一个存储单元。</p>
                        <p><strong>编址方式：</strong></p>
                        <ul>
                            <li>按字节编址：每个存储单元大小为1字节</li>
                            <li>按字编址：每个存储单元大小为1个字（每个字大小为16个二进制位）</li>
                        </ul>
                        <p><strong>实例：</strong>现代计算机普遍采用按字节编址，就像每间房都有唯一的门牌号。</p>
                        
                        <h4>3.1.2 地址类型</h4>
                        <p><strong><strong>物理地址</strong>（绝对地址）：</strong><strong>内存</strong>中实际的地址</p>
                        <p><strong>实例：</strong>就像房屋的真实地理位置，如北京市朝阳区某某街道123号。</p>
                        <p><strong><strong>逻辑地址</strong>（相对地址）：</strong>程序中使用的地址，与<strong>物理地址</strong>不同</p>
                        <p><strong>实例：</strong>就像楼层平面图上的房间号，如301室、302室。</p>
                        <p><strong>地址转换关系：</strong>起始地址（基址）+相对地址 = <strong>物理地址</strong></p>
                        <p><strong>实例：</strong>如果一栋楼的地址是北京市朝阳区某某街道123号，3层的301室的物理地址就是北京市朝阳区某某街道123号301室。</p>
                        
                        <h4>3.1.3 从写程序到程序运行</h4>
                        <p><strong>程序运行过程：</strong></p>
                        <ol>
                            <li>编辑源代码文件</li>
                            <li>编译（将源代码转换为目标代码）</li>
                            <li>链接（将目标代码与库函数链接）</li>
                            <li>装入（将可执行文件装入<span class="highlight">内存</span>）</li>
                            <li>执行（<span class="highlight">CPU</span>执行指令）</li>
                        </ol>
                        <p><strong>实例：</strong>写作文（编辑）→老师批改（编译）→装订成册（链接）→放到书架上（装入）→阅读（执行）。</p>
                        
                        <h4>3.1.4 链接的三种方式</h4>
                        <p><strong><strong>静态链接</strong>：</strong>在编译时将目标代码与库函数链接，生成可执行文件</p>
                        <p><strong>实例：</strong>制作静态链接的PDF文档，所有内容都嵌入在一个文件中。</p>
                        <p><strong><strong>装入时动态链接</strong>：</strong>在装入<span class="highlight">内存</span>时才链接目标代码与库函数</p>
                        <p><strong>实例：</strong>Word文档中插入的对象在打开文档时才链接到源文件。</p>
                        <p><strong><strong>运行时动态链接</strong>：</strong>在程序执行过程中才链接目标代码与库函数</p>
                        <p><strong>实例：</strong>网页中的JavaScript库在需要时才从CDN加载。</p>
                        
                        <h4>3.1.5 装入的三种方式</h4>
                        <p><strong><strong>绝对装入</strong>：</strong></p>
                        <ul>
                            <li>提前知道程序的<span class="highlight">内存</span>位置</li>
                            <li>在装入前直接修改程序中的地址</li>
                            <li>仅适用于单道程序环境</li>
                        </ul>
                        <p><strong>实例：</strong>预订酒店时确定房间号，入住时直接去指定房间。</p>
                        
                        <p><strong><strong>可重定位装入</strong>（静态重定位）：</strong></p>
                        <ul>
                            <li>装入时修改程序中的地址</li>
                            <li>必须分配其要求的全部<span class="highlight">内存</span>空间</li>
                            <li>在运行期间不能移动</li>
                        </ul>
                        <p><strong>实例：</strong>搬家时提前测量新家尺寸，购买合适尺寸的家具。</p>
                        
                        <p><strong><strong>动态重定位</strong>（动态装入）：</strong></p>
                        <ul>
                            <li>装入<span class="highlight">内存</span>时使用<span class="highlight">逻辑地址</span></li>
                            <li>运行时才转换为<span class="highlight">物理地址</span></li>
                            <li>需要一个重定位寄存器（存放装入起始地址）</li>
                            <li>允许程序在<span class="highlight">内存</span>中发生移动</li>
                        </ul>
                        <p><strong>实例：</strong>GPS导航系统，实时计算当前位置到目的地的路线。</p>
                        
                        <h4>3.1.6 <strong>内存管理</strong>的四大功能</h4>
                        <ol>
                            <li><strong><span class="highlight">内存分配</span></strong>：为<span class="highlight">进程</span>分配<span class="highlight">内存</span>空间</li>
                            <li><strong><span class="highlight">内存保护</span></strong>：确保各<span class="highlight">进程</span>在各自存储空间内运行，互不干扰</li>
                            <li><strong><span class="highlight">地址映射</span></strong>：将<span class="highlight">逻辑地址</span>转换为<span class="highlight">物理地址</span></li>
                            <li><strong><span class="highlight">内存扩充</span></strong>：通过<span class="highlight">虚拟内存</span>技术，从<span class="highlight">逻辑</span>上扩充<span class="highlight">内存</span></li>
                        </ol>
                        <p><strong>实例：</strong>物业管理处分配房间（内存分配）、门禁系统防止串门（内存保护）、楼层指示牌指引方向（地址映射）、临时住宿安排（内存扩充）。</p>
                    </div>
                </details>
                
                <details>
                    <summary>3.2 连续分配管理方式</summary>
                    <div>
                        <h4>3.2.1 单一连续分配</h4>
                        <p><strong>定义：</strong><span class="highlight">内存</span>划分为<span class="highlight">系统</span>区和<span class="highlight">用户</span>区，<span class="highlight">系统</span>区用于存放<span class="highlight">操作系统</span>，<span class="highlight">用户</span>区用于存放<span class="highlight">用户</span>程序</p>
                        <p><strong>实例：</strong>公寓楼分为物业办公区和住户居住区。</p>
                        <p><strong>特点：</strong></p>
                        <ul>
                            <li>每次只允许一个<span class="highlight">用户</span>程序在<span class="highlight">内存</span>中运行</li>
                            <li><span class="highlight">系统</span>区：操作系统占用的区域</li>
                            <li><span class="highlight">用户</span>区：用户程序占用的区域</li>
                        </ul>
                        <p><strong>实例：</strong>早期的MS-DOS系统就是采用这种方式。</p>
                        
                        <p><strong><strong>内部碎片</strong>：</strong>好比房子买来收租的，有个房间没租出去</p>
                        <p><strong><strong>外部碎片</strong>：</strong>这个小区有房子一直没卖出去</p>
                        <p><strong>实例：</strong>内部碎片就像一套三居室只住一个人，浪费了其他房间；外部碎片就像小区里有些楼房完全空置。</p>
                        
                        <p><strong>优点：</strong>实现简单</p>
                        <p><strong>缺点：</strong>内存利用率低</p>
                        <p><strong>实例：</strong>就像独栋别墅虽然舒适但土地利用率低。</p>
                        
                        <h4>3.2.2 固定分区分配</h4>
                        <p><strong>定义：</strong>将<span class="highlight">内存</span>划分为若干个固定大小的分区</p>
                        <p><strong>实例：</strong>学生宿舍楼按年级或专业划分楼层。</p>
                        <p><strong>特点：</strong></p>
                        <ul>
                            <li>分区大小可以相等（等大小分区）</li>
                            <li>分区大小可以不等（不等大小分区）</li>
                            <li>分区数量：由<span class="highlight">系统</span>决定，运行时不能改变</li>
                        </ul>
                        <p><strong>实例：</strong>停车场划分为小车区、大车区、摩托车区。</p>
                        
                        <p><strong>优点：</strong>实现简单，无外部碎片</p>
                        <p><strong>缺点：</strong></p>
                        <ul>
                            <li>分区数量限制活跃<span class="highlight">进程</span>数</li>
                            <li>小型作业无法有效利用分区</li>
                            <li>会产生<span class="highlight">内部</span><span class="highlight">碎片</span>（如果分区大小与作业大小不匹配）</li>
                        </ul>
                        <p><strong>实例：</strong>标准集装箱虽然便于管理，但小货物装不满会浪费空间。</p>
                        
                        <h4>3.2.3 动态分区分配</h4>
                        <p><strong>定义：</strong>根据<span class="highlight">进程</span>的大小动态地划分<span class="highlight">内存</span>空间</p>
                        <p><strong>实例：</strong>自助餐厅根据客人人数安排合适大小的餐桌。</p>
                        <p><strong>特点：</strong></p>
                        <ul>
                            <li>分区大小不固定</li>
                            <li>分区数量不固定</li>
                            <li>采用"定制化"方式分配<span class="highlight">内存</span></li>
                        </ul>
                        <p><strong>实例：</strong>定制服装比标准尺码更合身。</p>
                        
                        <p><strong>优点：</strong>内存利用率高</p>
                        <p><strong>缺点：</strong>会产生<span class="highlight">外部</span><span class="highlight">碎片</span></p>
                        <p><strong>实例：</strong>裁缝店按客人身材定制衣服节省布料，但剩余的碎布难以再利用。</p>
                        
                        <h4>3.2.4 <strong>动态分区分配算法</strong></h4>
                        <p><strong><strong>首次适应算法</strong>（First Fit）：</strong></p>
                        <ul>
                            <li>从低地址开始查找，找到第一个满足大小要求的<span class="highlight">空闲</span>分区</li>
                            <li>优点：实现简单</li>
                            <li>缺点：低地址区域容易产生大量小<span class="highlight">碎片</span></li>
                        </ul>
                        <p><strong>实例：</strong>在书店找座位，从入口开始找第一个空位坐下。</p>
                        
                        <p><strong><strong>最佳适应算法</strong>（Best Fit）：</strong></p>
                        <ul>
                            <li>从所有<span class="highlight">空闲</span>分区中找出满足大小要求的最小分区</li>
                            <li>优点：可以充分利用<span class="highlight">内存</span></li>
                            <li>缺点：会产生大量难以利用的小<span class="highlight">碎片</span></li>
                        </ul>
                        <p><strong>实例：</strong>收拾行李箱时，把小物品放在刚好能装下的小袋子里。</p>
                        
                        <p><strong><strong>最坏适应算法</strong>（Worst Fit）：</strong></p>
                        <ul>
                            <li>从所有<span class="highlight">空闲</span>分区中找出满足大小要求的最大分区</li>
                            <li>优点：保留了较大的<span class="highlight">空闲</span>分区</li>
                            <li>缺点：容易产生大量小<span class="highlight">碎片</span></li>
                        </ul>
                        <p><strong>实例：</strong>大型聚会优先使用最大的会议室。</p>
                        
                        <p><strong><strong>邻近适应算法</strong>（Next Fit）：</strong></p>
                        <ul>
                            <li>从上次分配的位置开始查找</li>
                            <li>优点：减少扫描时间</li>
                            <li>缺点：可能产生更多<span class="highlight">碎片</span></li>
                        </ul>
                        <p><strong>实例：</strong>在圆形餐桌找座位，从上一个人坐的位置开始顺时针寻找。</p>
                    </div>
                </details>
                
                <details>
                    <summary>3.3 非连续分配管理方式</summary>
                    <div>
                        <h4>3.3.1 分页存储管理方式</h4>
                        <p><strong><strong>分页存储管理方式</strong>：</strong></p>
                        <p><strong>实例：</strong>把一本书按页码分割，每页固定大小，可以分散放在不同的书架上。</p>
                        <p><strong><strong>页表</strong>：</strong>用于记录<span class="highlight">逻辑</span>页与<span class="highlight">物理</span>页框的对应关系</p>
                        <p><strong>实例：</strong>像地图索引，标明第几页内容在哪个书架上。</p>
                        <p><strong><strong>页内地址</strong>：</strong><span class="highlight">逻辑地址</span>的低部分，表示在页内的偏移量</p>
                        <p><strong><strong>页号</strong>：</strong><span class="highlight">逻辑地址</span>的高部分，表示<span class="highlight">逻辑</span>页的编号</p>
                        <p><strong>实例：</strong>书籍的页码由章节号和页内行号组成。</p>
                        
                        <!-- 添加实例按钮 -->
                        <div class="example-buttons">
                            <button class="example-btn" onclick="openExampleModal('basic-example')">基础地址转换示例</button>
                            <button class="example-btn" onclick="openExampleModal('tlb-example')">快表地址转换示例</button>
                            <button class="example-btn" onclick="openExampleModal('two-level-example')">两级页表示例</button>
                        </div>
                        
                        <div class="visualization">
                            <h4>分页存储管理地址变换过程</h4>
                            <pre>
    逻辑地址(32位)             页表              物理地址
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   页号(20位)   │───▶│  页框号(12位)  │───▶│  物理地址(32位) │
├─────────────┤    └─────────────┘    └─────────────┘
│ 页内偏移(12位) │                          │ 页框号×页大小+ │
└─────────────┘    ┌─────────────┐    │  页内偏移   │
                   │   页表项    │    └─────────────┘
                   │ 页框号(20位) │
                   │   标志位    │
                   └─────────────┘
                            </pre>
                            <p>说明：页号用于索引页表得到页框号，页内偏移保持不变，组合成物理地址</p>
                        </div>
                        
                        <h4>3.3.1.1 地址变换机构</h4>
                        <p><strong><strong>基本地址变换机构</strong>：</strong></p>
                        <ul>
                            <li><span class="highlight">逻辑地址</span> = <span class="highlight">页号</span> + <span class="highlight">页内地址</span></li>
                            <li><span class="highlight">页表</span>地址 = <span class="highlight">页号</span> × <span class="highlight">页表</span>项长度 + <span class="highlight">页表</span>起始地址</li>
                            <li><span class="highlight">物理地址</span> = <span class="highlight">页框号</span> × 页大小 + <span class="highlight">页内地址</span></li>
                        </ul>
                        <p><strong>实例：</strong>快递地址由省份代码+市内地址组成，通过邮编索引找到具体投递点。</p>
                        
                        <p><strong><strong>具有快表的地址变换机构</strong>：</strong></p>
                        <ul>
                        <p><strong><strong>快表</strong>（TLB）：</strong><span class="highlight">高速缓存</span>，用于存储最近使用的<span class="highlight">页表</span>项</p>
                            <li>原理：利用<span class="highlight">局部性</span>原理，提高地址变换速度</li>
                            <li><strong>TLB命中</strong>：直接从<strong>快表</strong>中获取<span class="highlight">页框号</span></li>
                            <li><strong>TLB未命中</strong>：需要访问<span class="highlight">内存</span>中的<strong>页表</strong>，同时将<strong>页表</strong>项存入<strong>快表</strong></li>
                            <li>特点：当新<span class="highlight">进程</span>上处理机运行时，<span class="highlight">快表</span>的内容会被清除</li>
                        </ul>
                        <p><strong>实例：</strong>常用联系人保存在手机通讯录首页，不需要每次都翻到最后查找。</p>
                        
                        <div class="visualization">
                            <h4>具有快表的地址变换过程</h4>
                            <pre>
    逻辑地址             快表(TLB)           页表              物理地址
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   页号(P)   │───▶│   页号(P)   │    │   页号(P)   │    │  物理地址   │
├─────────────┤    ├─────────────┤    ├─────────────┤    ├─────────────┤
│ 页内偏移(d) │    │   页框号(f) │    │   页框号(f) │    │  f × 页大小  │
└─────────────┘    │   标志位    │    │   标志位    │    │     +d      │
                   └─────────────┘    └─────────────┘    └─────────────┘
                         ▲                    │
                         └─────未命中时查询─────┘
                            </pre>
                            <p>说明：TLB命中时直接获取页框号，未命中时需要查询页表并将结果存入TLB</p>
                        </div>
                        
                        <p><strong><strong>两级页表</strong>：</strong></p>
                        <ul>
                            <li>为解决大<span class="highlight">页表</span>占用<span class="highlight">内存</span>的问题</li>
                            <li><span class="highlight">页表</span>分为两级：<span class="highlight">外层页表</span>和<span class="highlight">内层页表</span></li>
                            <li><span class="highlight">逻辑地址</span>分为三部分：<span class="highlight">外层页号</span>、<span class="highlight">内层页号</span>、<span class="highlight">页内偏移量</span></li>
                            <li>优点：减少<span class="highlight">页表</span>占用<span class="highlight">内存</span>空间</li>
                        </ul>
                        <p><strong>实例：</strong>图书馆索引分为类别索引和具体书目索引两层。</p>
                        
                        <h4>3.3.2 分段存储管理方式</h4>
                        <p><strong><strong>分段存储管理方式</strong>：</strong></p>
                        <p><strong>实例：</strong>一本书分为目录、正文、附录等不同部分，每部分独立编号。</p>
                        <p><strong><strong>段表</strong>：</strong>用于记录段的起始地址和长度</p>
                        <p><strong>实例：</strong>书籍的目录标明各章节的起始页码和页数。</p>
                        <p><strong><strong>段内地址</strong>：</strong><span class="highlight">逻辑地址</span>的低部分，表示在段内的偏移量</p>
                        <p><strong><strong>段号</strong>：</strong><span class="highlight">逻辑地址</span>的高部分，表示段的编号</p>
                        <p><strong>实例：</strong>学术论文的引用格式：[章节号].[段内编号]。</p>
                        
                        <p><strong>特点：</strong></p>
                        <ul>
                            <li>各个分段是按逻辑功能模块来划分的</li>
                            <li>段名由用户定义，可读性高</li>
                            <li>分段行为对用户是可见的</li>
                            <li>用户知道自己的进程会被分为几个段</li>
                        </ul>
                        <p><strong>实例：</strong>软件项目的模块化设计，如用户界面模块、业务逻辑模块、数据访问模块。</p>
                        
                        <p><strong>地址转换：</strong></p>
                        <ul>
                            <li><span class="highlight">逻辑地址</span> = <span class="highlight">段号</span> + <span class="highlight">段内地址</span></li>
                            <li><span class="highlight">物理地址</span> = 段基址 + <span class="highlight">段内地址</span></li>
                        </ul>
                        <p><strong>实例：</strong>办公楼房间号由楼层号+房间号组成，实际位置=楼层起始位置+房间号。</p>
                        
                        <h4>3.3.3 段页式管理方式</h4>
                        <p><strong><strong>段页式管理方式</strong>：</strong></p>
                        <p><strong>结构：</strong>将<span class="highlight">逻辑地址</span>空间先分段，再将每个段分页</p>
                        <p><strong>实例：</strong>大型书籍先分章节（段），再按页码（页）管理。</p>
                        
                        <p><strong>地址转换：</strong></p>
                        <ul>
                            <li><span class="highlight">逻辑地址</span> = <span class="highlight">段号</span> + <span class="highlight">页号</span> + <span class="highlight">页内偏移量</span></li>
                            <li>通过<span class="highlight">段表</span>找到<span class="highlight">页表</span>起始地址</li>
                            <li>通过<span class="highlight">页表</span>找到<span class="highlight">物理</span>页框号</li>
                            <li><span class="highlight">物理地址</span> = <span class="highlight">页框号</span> × 页大小 + <span class="highlight">页内偏移量</span></li>
                        </ul>
                        <p><strong>实例：</strong>大学课程编码：[学院代码][课程代码][课时编号]。</p>
                        
                        <div class="visualization">
                            <h4>段页式管理地址变换过程</h4>
                            <pre>
    逻辑地址              段表              页表              物理地址
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   段号(S)   │───▶│ 页表始址(L) │───▶│  页框号(f)  │───▶│  物理地址   │
├─────────────┤    ├─────────────┤    ├─────────────┤    ├─────────────┤
│   页号(P)   │    │   段长    │    │   标志位    │    │  f × 页大小  │
├─────────────┤    └─────────────┘    └─────────────┘    │     +d      │
│ 页内偏移(d) │                                           └─────────────┘
└─────────────┘
                            </pre>
                            <p>说明：段号用于索引段表得到页表起始地址，页号用于索引页表得到页框号，组合成物理地址</p>
                        </div>
                        
                        <p><strong>特点：</strong></p>
                        <ul>
                            <li>既满足了分段的<span class="highlight">逻辑</span>性，又满足了分页的<span class="highlight">物理</span>实现</li>
                            <li>既解决了<span class="highlight">外部</span><span class="highlight">碎片</span>问题，又保留了<span class="highlight">逻辑</span>上的分段</li>
                        </ul>
                        <p><strong>实例：</strong>现代操作系统如Windows和Linux都采用段页式管理。</p>
                    </div>
                </details>
                
                <details>
                    <summary>3.4 虚拟内存管理</summary>
                    <div>
                        <h4>3.4.1 虚拟内存的基本概念</h4>
                        <p><strong><strong>虚拟内存</strong>的基本概念：</strong></p>
                        <p><strong>实例：</strong>就像云存储让用户感觉拥有无限大的硬盘空间。</p>
                        <p><strong>目的：</strong>解决<span class="highlight">内存</span>容量不足的问题</p>
                        <p><strong>原理：</strong>利用<span class="highlight">局部性</span>原理，将暂时不用的<span class="highlight">内存</span>内容交换到<span class="highlight">外存</span></p>
                        <p><strong>实例：</strong>整理衣柜时，把不常穿的衣服放到储物间，需要时再取回来。</p>
                        
                        <h4>3.4.2 请求分页管理方式</h4>
                        <p><strong><strong>请求分页管理方式</strong>：</strong></p>
                        <p><strong>实例：</strong>在线视频的流媒体播放，边下载边观看。</p>
                        <p><strong>特点：</strong></p>
                        <ul>
                            <li>程序运行前不需要将全部页面调入<span class="highlight">内存</span></li>
                            <li>需要<span class="highlight">页面置换算法</span></li>
                            <li>需要请求调页机制</li>
                        </ul>
                        <p><strong>实例：</strong>手机应用按需加载功能模块，而不是一次性加载所有功能。</p>
                        
                        <p><strong>请求分页的精髓：</strong></p>
                        <ol>
                            <li>应该在什么时候请求调页</li>
                            <li>什么时候进行页面置换</li>
                            <li>当调页和页面置换完成之后要对哪些数据结构进行修改</li>
                        </ol>
                        <p><strong>实例：</strong>图书馆的图书借阅系统，根据读者需求调拨图书，根据库存情况决定归还哪些图书。</p>
                        
                        <h4>3.4.3 <strong>页面置换算法</strong></h4>
                        <p><strong><strong>最佳置换算法</strong>（OPT）：</strong></p>
                        <ul>
                            <li>选择永不使用或最长时间内不再被访问的页面予以淘汰</li>
                            <li>优点：<span class="highlight">缺页</span>率最低，理论最优</li>
                            <li>缺点：无法预知未来，实际中不可实现</li>
                        </ul>
                        <p><strong>实例：</strong>就像清理衣柜时，把将来最不可能穿的衣服扔掉。</p>
                        
                        <div class="study-tip-container">
                            <button class="study-tip-btn" onclick="toggleStudyTip('opt-algorithm-tip')">💡 学习提示</button>
                            <div id="opt-algorithm-tip" class="study-tip-content" style="display:none;">
                                <h4>记忆方法：</h4>
                                <p><strong>OPT（Optimal）</strong> - "最优"的英文缩写</p>
                                <ul>
                                    <li>关键词："最佳"、"最优"</li>
                                    <li>联想记忆：理想主义算法，完美预测未来，现实中不存在</li>
                                    <li>口诀："最佳置换最理想，可惜未来难预知"</li>
                                </ul>
                            </div>
                        </div>
                        
                        <p><strong><strong>先进先出算法</strong>（FIFO）：</strong></p>
                        <ul>
                            <li>选择最先进入<span class="highlight">内存</span>的页面予以淘汰</li>
                            <li>优点：实现简单</li>
                            <li>缺点：可能出现<span class="highlight">Belady</span>现象（分配的<span class="highlight">物理</span>页面数增加，<span class="highlight">缺页</span>次数反而增加）</li>
                        </ul>
                        <p><strong>实例：</strong>就像快餐店的队列，先排队的先买到食物。</p>
                        
                        <div class="study-tip-container">
                            <button class="study-tip-btn" onclick="toggleStudyTip('fifo-algorithm-tip')">💡 学习提示</button>
                            <div id="fifo-algorithm-tip" class="study-tip-content" style="display:none;">
                                <h4>记忆方法：</h4>
                                <p><strong>FIFO（First In First Out）</strong> - "先进先出"的英文缩写</p>
                                <ul>
                                    <li>关键词："先进先出"、"队列"</li>
                                    <li>联想记忆：超市收银台排队，先来的先结账</li>
                                    <li>口诀："先进先出排好队，实现简单易理解"</li>
                                </ul>
                            </div>
                        </div>
                        
                        <p><strong><strong>最近最久未使用算法</strong>（LRU）：</strong></p>
                        <ul>
                            <li>选择最近最久未访问的页面予以淘汰</li>
                            <li>优点：性能较好，接近<span class="highlight">OPT</span><span class="highlight">算法</span></li>
                            <li>缺点：实现较为复杂，需要硬件支持</li>
                        </ul>
                        <p><strong>实例：</strong>就像图书馆管理员清理书架，把最长时间没人借阅的书移走。</p>
                        
                        <div class="study-tip-container">
                            <button class="study-tip-btn" onclick="toggleStudyTip('lru-algorithm-tip')">💡 学习提示</button>
                            <div id="lru-algorithm-tip" class="study-tip-content" style="display:none;">
                                <h4>记忆方法：</h4>
                                <p><strong>LRU（Least Recently Used）</strong> - "最近最少使用"的英文缩写</p>
                                <ul>
                                    <li>关键词："最近"、"最少"、"使用"</li>
                                    <li>联想记忆：遗忘曲线，越久不用越容易忘，越久不访问越可能不再访问</li>
                                    <li>口诀："最近最少快淘汰，性能接近最佳解"</li>
                                </ul>
                            </div>
                        </div>
                        
                        <p><strong><strong>时钟置换算法</strong>（CLOCK）：</strong></p>
                        <ul>
                            <li>为每个页面设置一个访问位，将页面连接成一个环形链表</li>
                            <li>优点：实现相对简单，性能接近<span class="highlight">LRU</span></li>
                            <li>缺点：需要硬件支持访问位</li>
                        </ul>
                        <p><strong>实例：</strong>就像时钟的指针，一圈一圈地扫描，找到合适的页面淘汰。</p>
                        
                        <div class="study-tip-container">
                            <button class="study-tip-btn" onclick="toggleStudyTip('clock-algorithm-tip')">💡 学习提示</button>
                            <div id="clock-algorithm-tip" class="study-tip-content" style="display:none;">
                                <h4>记忆方法：</h4>
                                <p><strong>CLOCK（时钟算法）</strong></p>
                                <ul>
                                    <li>关键词："时钟"、"环形"、"指针"</li>
                                    <li>联想记忆：像时钟指针一样循环扫描页面</li>
                                    <li>口诀："时钟算法转圈圈，找到目标就淘汰"</li>
                                </ul>
                            </div>
                        </div>
                        
                        <h4>3.4.4 请求分段管理方式</h4>
                        <p><strong><strong>请求分段管理方式</strong>：</strong></p>
                        <p><strong>实例：</strong>在线游戏按场景加载地图数据，不在当前场景的地图不加载。</p>
                        <p><strong>特点：</strong></p>
                        <ul>
                            <li>段可以部分调入<span class="highlight">内存</span></li>
                            <li>适合<span class="highlight">逻辑</span>上独立的程序模块</li>
                            <li>可以提高<span class="highlight">内存</span>利用率</li>
                        </ul>
                        <p><strong>实例：</strong>网站的懒加载技术，只加载用户当前可见的内容。</p>
                    </div>
                </details>
                
                <details>
                    <summary>3.5 内存保护</summary>
                    <div>
                        <h4>3.5.1 内存保护的必要性</h4>
                        <p><strong><strong>内存保护</strong>的必要性：</strong></p>
                        <p><strong>实例：</strong>住宅小区的门禁系统，防止陌生人进入他人家中。</p>
                        <p><strong>风险：</strong>一个<span class="highlight">进程</span>可能访问其他<span class="highlight">进程</span>的<span class="highlight">内存</span>空间，导致<span class="highlight">系统</span>崩溃</p>
                        <p><strong>实例：</strong>银行账户系统如果被非法访问，可能导致资金损失。</p>
                        
                        <h4>3.5.2 内存保护的实现方式</h4>
                        <p><strong><strong>内存保护</strong>的实现方式：</strong></p>
                        <ul>
                            <li><strong>上限寄存器</strong>：存放<span class="highlight">进程</span>的最大地址</li>
                            <li><strong>下限寄存器</strong>：存放<span class="highlight">进程</span>的最小地址</li>
                            <li>每次访问<span class="highlight">内存</span>时，检查地址是否在界限范围内</li>
                        </ul>
                        <p><strong>实例：</strong>身份证的有效期，超出期限就失效。</p>
                        
                        <p><strong><strong>重定位寄存器</strong>（基址寄存器）：</strong></p>
                        <ul>
                            <li>存放<span class="highlight">进程</span>的起始地址</li>
                            <li><span class="highlight">逻辑地址</span> = <span class="highlight">重定位寄存器</span> + <span class="highlight">逻辑地址</span></li>
                            <li>保护机制：确保<span class="highlight">逻辑地址</span>在<span class="highlight">进程</span>的地址空间内</li>
                        </ul>
                        <p><strong>实例：</strong>地图上的坐标系原点，所有位置都相对于原点计算。</p>
                        
                        <p><strong><strong>段表保护</strong>：</strong></p>
                        <ul>
                            <li>在<span class="highlight">段表</span>中设置段的界限</li>
                            <li>访问段时检查段内地址是否在界限范围内</li>
                        </ul>
                        <p><strong>实例：</strong>文件夹的访问权限设置，防止越级访问。</p>
                        
                        <p><strong><strong>页表保护</strong>：</strong></p>
                        <ul>
                            <li>在<span class="highlight">页表</span>中设置页的保护位</li>
                            <li>访问页时检查是否具有访问权限</li>
                        </ul>
                        <p><strong>实例：</strong>操作系统中的用户权限管理，不同用户有不同的文件访问权限。</p>
                    </div>
                </details>
                
                <details>
                    <summary>3.6 覆盖与交换</summary>
                    <div>
                        <h4>3.6.1 覆盖技术</h4>
                        <p><strong><strong>覆盖技术</strong>：</strong></p>
                        <p><strong>实例：</strong>手机应用的插件机制，主程序固定，功能插件按需加载。</p>
                        <p><strong>工作原理：</strong></p>
                        <ul>
                            <li>通常将程序中经常使用的部分（如主程序）放在固定区</li>
                            <li>将其他部分放在覆盖区</li>
                            <li>程序执行时，需要时才将覆盖区的内容调入<span class="highlight">内存</span></li>
                        </ul>
                        <p><strong>实例：</strong>游戏的主程序始终驻留内存，关卡数据按需加载。</p>
                        
                        <p><strong>特点：</strong></p>
                        <ul>
                            <li>由程序员声明覆盖结构</li>
                            <li><span class="highlight">操作系统</span>完成自动覆盖</li>
                            <li>对<span class="highlight">用户</span>不透明</li>
                            <li>适用于早期<span class="highlight">操作系统</span>，现在已成为历史</li>
                        </ul>
                        <p><strong>实例：</strong>早期DOS游戏使用覆盖技术在有限内存中运行大型游戏。</p>
                        
                        <h4>3.6.2 交换技术</h4>
                        <p><strong><strong>交换技术</strong>：</strong></p>
                        <p><strong>实例：</strong>酒店的客房调度，空闲房间给新客人，老客人外出时房间可以给其他人使用。</p>
                        <p><strong>工作原理：</strong></p>
                        <ul>
                            <li>当<span class="highlight">内存</span>不足时，将某些<span class="highlight">进程</span>从<span class="highlight">内存</span>换出到<span class="highlight">外存</span></li>
                            <li>当需要运行时，将<span class="highlight">进程</span>从<span class="highlight">外存</span>换入<span class="highlight">内存</span></li>
                        </ul>
                        <p><strong>实例：</strong>手机后台应用冻结机制，释放内存给前台应用使用。</p>
                        
                        <p><strong>换出过程：</strong></p>
                        <ol>
                            <li>选择要换出的<span class="highlight">进程</span></li>
                            <li>将<span class="highlight">进程</span>的<span class="highlight">内存</span>内容写入<span class="highlight">外存</span></li>
                            <li>释放<span class="highlight">进程</span>占用的<span class="highlight">内存</span></li>
                        </ol>
                        <p><strong>实例：</strong>酒店客人外出旅行时，行李寄存到保险柜中。</p>
                        
                        <p><strong>换入过程：</strong></p>
                        <ol>
                            <li>选择要换入的<span class="highlight">进程</span></li>
                            <li>从<span class="highlight">外存</span>读取<span class="highlight">进程</span>的<span class="highlight">内存</span>内容</li>
                            <li>为<span class="highlight">进程</span>分配<span class="highlight">内存</span></li>
                        </ol>
                        <p><strong>实例：</strong>客人返回酒店时，从保险柜取出行李放回房间。</p>
                        
                        <p><strong><strong>挂起状态</strong>：</strong></p>
                        <ul>
                            <li>暂时换出<span class="highlight">外存</span>等待的<span class="highlight">进程</span>状态为<span class="highlight">挂起状态</span></li>
                            <li><span class="highlight">挂起态</span>又可以细分为<span class="highlight">就绪</span><span class="highlight">挂起</span>和<span class="highlight">阻塞</span><span class="highlight">挂起</span></li>
                            <li><span class="highlight">PCB</span>：<span class="highlight">进程</span>控制块常驻<span class="highlight">内存</span>，不会被换出<span class="highlight">外存</span></li>
                        </ul>
                        <p><strong>实例：</strong>学生的学籍保留状态，在服兵役期间学籍挂起，但档案信息仍然保存。</p>
                        
                        <h4>3.6.3 覆盖与交换的区别</h4>
                        <p><strong><strong>覆盖与交换</strong>的区别：</strong></p>
                        <p><strong>实例：</strong>应用程序的不同功能模块之间的切换。</p>
                        <p><strong>交换：</strong>不同<span class="highlight">进程</span>（或作业）之间的操作</p>
                        <p><strong>实例：</strong>操作系统在多个应用程序之间切换。</p>
                    </div>
                </details>
                
                <details>
                    <summary>3.7 本章核心考点总结</summary>
                    <div>
                        <ol>
                            <li><strong>内存管理</strong>的四大功能：<strong><span class="highlight">内存分配</span></strong>、<strong><span class="highlight">内存保护</span></strong>、<strong><span class="highlight">地址映射</span></strong>、<strong><span class="highlight">内存扩充</span></strong></li>
                            <li>连续分配管理方式：
                                <ul>
                                    <li>单一连续分配</li>
                                    <li>固定分区分配</li>
                                    <li>动态分区分配</li>
                                    <li><strong><span class="highlight">动态分区分配算法</span></strong>（<strong><span class="highlight">首次适应</span></strong>、<strong><span class="highlight">最佳适应</span></strong>、<strong><span class="highlight">最坏适应</span></strong>、<strong><span class="highlight">邻近适应</span></strong>）</li>
                                </ul>
                            </li>
                            <li>非连续分配管理方式：
                                <ul>
                                    <li><strong><span class="highlight">分页存储管理方式</span></strong>（<strong><span class="highlight">地址变换</span></strong>、<strong><span class="highlight">快表</span></strong>、<strong><span class="highlight">两级页表</span></strong>）</li>
                                    <li>分段存储管理方式</li>
                                    <li>段页式存储管理方式</li>
                                </ul>
                            </li>
                            <li><span class="highlight">虚拟内存</span>管理：
                                <ul>
                                    <li>请求分页管理方式</li>
                                    <li><strong><span class="highlight">页面置换算法</span></strong>（<span class="highlight">FIFO</span>、<span class="highlight">OPT</span>、<span class="highlight">LRU</span>、<span class="highlight">Clock</span>）</li>
                                </ul>
                            </li>
                            <li><span class="highlight">内存保护</span>：
                                <ul>
                                    <li><strong><span class="highlight">界限寄存器</span></strong></li>
                                    <li><strong><span class="highlight">重定位寄存器</span></strong></li>
                                    <li><strong><span class="highlight">段表保护</span></strong></li>
                                    <li><strong><span class="highlight">页表保护</span></strong></li>
                                </ul>
                            </li>
                            <li>覆盖与交换：
                                <ul>
                                    <li><strong><span class="highlight">覆盖技术</span></strong></li>
                                    <li><strong><span class="highlight">交换技术</span></strong></li>
                                </ul>
                            </li>
                        </ol>
                        
                        <p><strong>实例总结：</strong></p>
                        <ul>
                            <li>内存管理就像房地产管理：分配房间（内存分配）、门禁系统（内存保护）、楼层索引（地址映射）、虚拟办公（内存扩充）</li>
                            <li>分页管理像书籍管理：按页码分页、建立索引、按需查阅</li>
                            <li>分段管理像文档结构：按章节分段、独立编号、逻辑清晰</li>
                            <li>虚拟内存像云存储：本地缓存常用数据，云端存储全部数据</li>
                            <li>页面置换算法像超市管理：先进先出、按需补货、智能推荐</li>
                        </ul>
                        
                        <p><strong>本章重要性：</strong>本章是<span class="highlight">操作系统</span>的核心内容，也是考研的重点和难点。<span class="highlight">内存管理</span>涉及多个概念和<span class="highlight">算法</span>，需要深入理解各种分配方式、地址转换机制和<span class="highlight">页面置换算法</span>。掌握本章内容，对理解<span class="highlight">操作系统</span>的工作原理和解决实际问题具有重要意义。</p>
                    </div>
                </details>
            </div>
            
            <div class="key-points">
                <h3>核心考点</h3>
                <ul>
                    <li><strong><span class="highlight">分页</span>/<span class="highlight">分段</span>/<span class="highlight">段页式</span></strong></li>
                    <li><strong><span class="highlight">页面置换算法</span></strong>（<span class="highlight">LRU</span>）</li>
                    <li><strong><span class="highlight">虚拟内存</span></strong></li>
                </ul>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 王道操作系统考研复习指导 - 学习网站</p>
        </div>
    </footer>

    <script src="script.js"></script>
    
    <!-- Mermaid.js 支持 -->
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            mindmap: {
                useMaxWidth: true,
                padding: 20,
                nodeSpacing: 60,
                rankSpacing: 100
            },
            themeVariables: {
                primaryColor: '#667eea',
                primaryBorderColor: '#764ba2',
                primaryTextColor: '#ffffff',
                secondaryColor: '#a8dcfa',
                secondaryBorderColor: '#8bc4f9',
                secondaryTextColor: '#333333',
                tertiaryColor: '#f5f7fa',
                tertiaryBorderColor: '#e4edf9',
                tertiaryTextColor: '#333333',
                lineColor: '#667eea',
                fontSize: 20
            }
        });
    </script>
    
    <!-- 回到顶部按钮 -->
    <button id="backToTop" class="back-to-top">↑</button>
    
    <!-- 示例弹窗 -->
    <div id="example-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeExampleModal()">&times;</span>
            <div id="modal-body"></div>
        </div>
    </div>
</body>
</html>